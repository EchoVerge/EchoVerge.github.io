<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OMR è¦–è¦ºåŒ–é™¤éŒ¯å¯¦é©—å®¤ (Debug Bench)</title>
    <script src="https://docs.opencv.org/4.8.0/opencv.js" async onload="onOpenCvReady()"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        function onOpenCvReady() {
            document.getElementById('status').innerText = "âœ… OpenCV è¼‰å…¥å®Œæˆï¼Œè«‹ä¸Šå‚³æª”æ¡ˆ";
            document.getElementById('status').style.color = "green";
        }
    </script>

    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; padding: 20px; }
        h1 { margin-bottom: 10px; }
        .controls { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .gallery { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .card { background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; }
        .card h3 { margin: 0 0 10px 0; font-size: 16px; color: #333; border-bottom: 2px solid #eee; padding-bottom: 5px; }
        .card canvas, .card img { width: 100%; height: auto; border: 1px solid #ccc; background: #eee; }
        .status-bar { font-weight: bold; margin-bottom: 10px; color: #666; }
        .json-result { background: #282c34; color: #abb2bf; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 200px; overflow: auto; white-space: pre-wrap; }
    </style>
</head>
<body>

    <h1>ğŸ” OMR è¦–è¦ºåŒ–é™¤éŒ¯å¯¦é©—å®¤</h1>
    <div id="status" class="status-bar">â³ ç­‰å¾… OpenCV è¼‰å…¥...</div>

    <div class="controls">
        <label style="font-weight: bold;">ä¸Šå‚³è€ƒå· (æ”¯æ´ JPG/PNG/PDF):</label>
        <br>
        <input type="file" id="fileInput" accept="image/*, .pdf" style="margin-top: 10px;">
        <button id="btnProcess" style="margin-left: 10px; padding: 5px 15px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">é–‹å§‹åˆ†æ</button>
        
        <div style="margin-top: 10px; font-size: 13px; color: #666;">
            * æ­¤å·¥å…·æœƒæ¨¡æ“¬ V31 çš„é‚è¼¯ï¼Œå°‡ä¸­é–“éç¨‹è¦–è¦ºåŒ–å‘ˆç¾ã€‚<br>
            * <b>å…¨åŸŸäºŒå€¼åŒ–</b>ï¼šç”¨æ–¼å°‹æ‰¾å®šä½é» (Block: 21, C: 5)<br>
            * <b>æ ¡æ­£å¾ŒäºŒå€¼åŒ–</b>ï¼šç”¨æ–¼åˆ¤è®€ç­”æ¡ˆ (Block: 15, C: 3)
        </div>
    </div>

    <div id="outputArea"></div>

    <script type="module">
        import { analyzeAnswerSheetLocal } from './assets/js/modules/localParser.js';
        import { convertPdfToImages } from './assets/js/modules/fileExtractor.js';

        const fileInput = document.getElementById('fileInput');
        const btnProcess = document.getElementById('btnProcess');
        const outputArea = document.getElementById('outputArea');

        btnProcess.addEventListener('click', async () => {
            if (fileInput.files.length === 0) {
                alert("è«‹å…ˆé¸æ“‡æª”æ¡ˆï¼");
                return;
            }
            
            outputArea.innerHTML = '<div style="text-align:center; padding:20px;">ğŸš€ æ­£åœ¨è™•ç†ä¸­...</div>';
            
            const file = fileInput.files[0];
            let imagesBase64 = [];

            try {
                if (file.type === 'application/pdf') {
                    imagesBase64 = await convertPdfToImages(file);
                } else {
                    const base64 = await readFileAsBase64(file);
                    imagesBase64 = [base64.split(',')[1]]; // å»é™¤ data:image prefix
                }

                // æ¸…ç©ºå€åŸŸ
                outputArea.innerHTML = '';

                // é€é è™•ç†
                for (let i = 0; i < imagesBase64.length; i++) {
                    await processPage(imagesBase64[i], i);
                }

            } catch (err) {
                console.error(err);
                alert("è™•ç†å¤±æ•—: " + err.message);
            }
        });

        async function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function processPage(base64, index) {
            // 1. åŸ·è¡Œæ­£å¼çš„é–±å·é‚è¼¯ (å–å¾—æœ€çµ‚çµæœ)
            // å‡è¨­é¡Œç›®æ•¸ç‚º 50 (é è¨­)
            const results = await analyzeAnswerSheetLocal([base64], 50);
            const finalResult = results[0];

            // 2. [è¦–è¦ºåŒ–] æ‰‹å‹•é‡è·‘ä¸€æ¬¡ OpenCV æµç¨‹ä»¥é¡¯ç¤ºä¸­é–“ç”¢ç‰©
            // å› ç‚º localParser æ²’æœ‰åŒ¯å‡ºä¸­é–“åœ–ï¼Œæˆ‘å€‘åœ¨é€™è£¡æ¨¡æ“¬å®ƒçš„æ­¥é©Ÿ
            
            const container = document.createElement('div');
            container.innerHTML = `<h2 style="border-top:2px dashed #ccc; padding-top:20px; margin-top:30px;">ğŸ“„ ç¬¬ ${index + 1} é </h2>`;
            const gallery = document.createElement('div');
            gallery.className = 'gallery';
            
            // --- Step A: åŸå§‹åœ– ---
            const imgEl = new Image();
            imgEl.src = "data:image/jpeg;base64," + base64;
            await new Promise(r => imgEl.onload = r);
            
            // --- Step B: OpenCV è™•ç† ---
            let src = cv.imread(imgEl);
            
            // Resize (Standardize)
            let resized = new cv.Mat();
            const STANDARD_WIDTH = 1000;
            const scaleFactor = STANDARD_WIDTH / src.cols;
            const newHeight = Math.round(src.rows * scaleFactor);
            cv.resize(src, resized, new cv.Size(STANDARD_WIDTH, newHeight), 0, 0, cv.INTER_AREA);

            // 1. å…¨åŸŸäºŒå€¼åŒ– (Global Binary)
            let gray = new cv.Mat();
            cv.cvtColor(resized, gray, cv.COLOR_RGBA2GRAY, 0);
            let binary = new cv.Mat();
            // V31 è¨­å®š: Block 21, C 5
            cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 21, 5);

            // 2. é€è¦–æ ¡æ­£ (Warp) - å˜—è©¦æ‰¾å®šä½é»
            // æ³¨æ„ï¼šé€™è£¡æˆ‘å€‘è¤‡è£½äº† helper function é‚è¼¯ä¾†åšè¦–è¦ºåŒ–
            let markers = findFiducialMarkers(binary);
            let warped = new cv.Mat();
            let warpedBinary = new cv.Mat();
            let isWarpSuccess = false;

            if (markers) {
                warped = fourPointTransform(resized, markers);
                isWarpSuccess = true;
                
                // 3. æ ¡æ­£å¾ŒäºŒå€¼åŒ– (Warped Binary)
                // V31 è¨­å®š: Block 15, C 3 (é€™å€‹æ˜¯ç”¨ä¾†æ‰¾ç­”æ¡ˆçš„é—œéµå½±åƒ)
                let warpedGray = new cv.Mat();
                cv.cvtColor(warped, warpedGray, cv.COLOR_RGBA2GRAY, 0);
                cv.adaptiveThreshold(warpedGray, warpedBinary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);
                warpedGray.delete();
            } else {
                // å¦‚æœæ‰¾ä¸åˆ°å®šä½é»ï¼Œå°±é¡¯ç¤ºåŸåœ–
                warped = resized.clone(); 
                cv.cvtColor(warped, warpedBinary, cv.COLOR_RGBA2GRAY, 0); // åªæ˜¯ç‚ºäº†ä¸å ±éŒ¯
                cv.adaptiveThreshold(warpedBinary, warpedBinary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);
            }

            // --- æ¸²æŸ“åˆ° DOM ---
            
            // Card 1: å…¨åŸŸäºŒå€¼åŒ– (æª¢æŸ¥å®šä½é»æ˜¯å¦å®Œæ•´)
            gallery.appendChild(createCanvasCard("1. å…¨åŸŸäºŒå€¼åŒ– (æ‰¾å®šä½é»)", binary));

            // Card 2: æ ¡æ­£å¾Œå½±åƒ (æª¢æŸ¥æ˜¯å¦åˆ‡æ­£)
            gallery.appendChild(createCanvasCard("2. é€è¦–æ ¡æ­£å¾Œ (Warped)", warped));

            // Card 3: æ ¡æ­£å¾ŒäºŒå€¼åŒ– (æª¢æŸ¥ç­”æ¡ˆæ˜¯å¦æ¸…æ™°) - é€™æ˜¯æœ€é‡è¦çš„é™¤éŒ¯åœ–ï¼
            gallery.appendChild(createCanvasCard("3. æ ¡æ­£å¾ŒäºŒå€¼åŒ– (æ‰¾ç­”æ¡ˆ)", warpedBinary));

            // Card 4: æœ€çµ‚åˆ†æçµæœ (ä¾†è‡ª localParser)
            const resCard = document.createElement('div');
            resCard.className = 'card';
            resCard.innerHTML = `<h3>4. æœ€çµ‚åˆ¤è®€çµæœ (Debug View)</h3>`;
            const resImg = new Image();
            if (finalResult.debugImage) {
                resImg.src = finalResult.debugImage;
            } else {
                resImg.alt = "ç„¡é™¤éŒ¯å½±åƒ";
            }
            resCard.appendChild(resImg);
            gallery.appendChild(resCard);

            // JSON çµæœ
            const jsonDiv = document.createElement('div');
            jsonDiv.style.marginTop = "20px";
            jsonDiv.innerHTML = `<h3>ğŸ“Š è­˜åˆ¥æ•¸æ“š (JSON)</h3><div class="json-result">åº§è™Ÿ: ${finalResult.seat}\nç­”æ¡ˆ: ${JSON.stringify(finalResult.answers)}</div>`;

            container.appendChild(gallery);
            container.appendChild(jsonDiv);
            outputArea.appendChild(container);

            // æ¸…ç†è¨˜æ†¶é«”
            src.delete(); resized.delete(); gray.delete(); binary.delete();
            warped.delete(); warpedBinary.delete();
        }

        function createCanvasCard(title, mat) {
            const card = document.createElement('div');
            card.className = 'card';
            const canvas = document.createElement('canvas');
            cv.imshow(canvas, mat);
            card.innerHTML = `<h3>${title}</h3>`;
            card.appendChild(canvas);
            return card;
        }

        // --- è¤‡è£½è‡ª localParser.js çš„ Helper Functions (ç‚ºäº†è¦–è¦ºåŒ–) ---
        // æ³¨æ„ï¼šé€™äº›å‡½æ•¸åœ¨ localParser å…§éƒ¨æ²’æœ‰ exportï¼Œæ‰€ä»¥é€™è£¡å¿…é ˆè¤‡è£½ä¸€ä»½ä»¥é€²è¡Œå‰ç«¯è¦–è¦ºåŒ–
        
        function findFiducialMarkers(binaryImage) {
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            cv.findContours(binaryImage, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            const candidates = [];
            const minArea = 150;
            const maxArea = 3000; 

            for (let i = 0; i < contours.size(); ++i) {
                let cnt = contours.get(i);
                let area = cv.contourArea(cnt);
                if (area >= minArea && area <= maxArea) {
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.04 * cv.arcLength(cnt, true), true);
                    if (approx.rows === 4 && cv.isContourConvex(approx)) {
                        let rect = cv.boundingRect(approx);
                        let ar = rect.width / parseFloat(rect.height);
                        if (ar >= 0.7 && ar <= 1.3) {
                            candidates.push({ x: rect.x + rect.width/2, y: rect.y + rect.height/2, contour: approx });
                        } else { approx.delete(); }
                    } else { approx.delete(); }
                }
                cnt.delete();
            }
            contours.delete(); hierarchy.delete();

            if (candidates.length < 4) return null;

            const w = binaryImage.cols;
            const h = binaryImage.rows;
            const corners = [{x:0,y:0}, {x:w,y:0}, {x:w,y:h}, {x:0,y:h}];
            let best = [null,null,null,null];
            let minDists = [Infinity,Infinity,Infinity,Infinity];

            candidates.forEach(cand => {
                for(let i=0; i<4; i++) {
                    let d = Math.pow(cand.x - corners[i].x, 2) + Math.pow(cand.y - corners[i].y, 2);
                    if (d < minDists[i]) { minDists[i] = d; best[i] = cand; }
                }
            });

            if (best.some(m => m === null)) return null;
            candidates.forEach(c => { if(c.contour) c.contour.delete(); });
            return best;
        }

        function fourPointTransform(image, markers) {
            const pts = markers.map(m => ({x: m.x, y: m.y}));
            pts.sort((a,b) => a.x - b.x);
            let lefts = pts.slice(0,2).sort((a,b)=>a.y-b.y);
            let rights = pts.slice(2,4).sort((a,b)=>a.y-b.y);
            const sorted = [lefts[0], rights[0], rights[1], lefts[1]]; 

            const maxWidth = 1000;
            const maxHeight = 1414;

            let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [sorted[0].x, sorted[0].y, sorted[1].x, sorted[1].y, sorted[2].x, sorted[2].y, sorted[3].x, sorted[3].y]);
            let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, maxWidth, 0, maxWidth, maxHeight, 0, maxHeight]);
            let M = cv.getPerspectiveTransform(srcTri, dstTri);
            let warped = new cv.Mat();
            cv.warpPerspective(image, warped, M, new cv.Size(maxWidth, maxHeight));
            
            srcTri.delete(); dstTri.delete(); M.delete();
            return warped;
        }
    </script>
</body>
</html>